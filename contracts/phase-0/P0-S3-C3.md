# Contract P0-S3-C3: Basic Camera System

## Metadata
- **Contract ID**: P0-S3-C3
- **System**: Basic Rendering
- **Priority**: Medium
- **Estimated Time**: 45 minutes
- **Dependencies**: P0-S3-C1
- **Version**: 1.0.0

## Description
Implement a basic 2D camera system that can follow the player and handle world-to-screen coordinate transformations. The camera should support smooth movement and basic bounds checking.

## UTF Test Blocks

### UTF-Block-P0-S3-C3-T1: Camera Positioning
```python
# Test: Camera positions correctly
def test_camera_positioning():
    """
    Given: Camera at world position (500, 500)
    When: Object at (500, 500) is transformed
    Then:
      - Screen position is (400, 300) (center of 800x600)
      - Objects offset correctly from center
      - Camera position updates smoothly
      - No integer rounding errors
    """
    # Error-Tags: ['TRANSFORM_ERROR', 'POSITION_INVALID']
```

### UTF-Block-P0-S3-C3-T2: World to Screen Transform
```python
# Test: World coordinates transform to screen correctly
def test_world_to_screen():
    """
    Given: Camera at (1000, 1000), screen 800x600
    When: World positions are transformed
    Then:
      - (1000, 1000) -> (400, 300) (screen center)
      - (1200, 1000) -> (600, 300) (right side)
      - (800, 1000) -> (200, 300) (left side)
      - Off-screen positions calculated correctly
    """
    # Error-Tags: ['TRANSFORM_MATH_ERROR', 'COORDINATE_OVERFLOW']
```

### UTF-Block-P0-S3-C3-T3: Camera Following
```python
# Test: Camera follows target smoothly
def test_camera_following():
    """
    Given: Camera following player entity
    When: Player moves from (0, 0) to (100, 0)
    Then:
      - Camera interpolates smoothly
      - No jittering or stuttering
      - Follows with configurable speed
      - Maintains offset if specified
      - Stops at world boundaries
    """
    # Error-Tags: ['FOLLOW_TARGET_NULL', 'SMOOTHING_FAILED']
```

### UTF-Block-P0-S3-C3-T4: Viewport Culling
```python
# Test: Only visible objects are flagged for rendering
def test_viewport_culling():
    """
    Given: Camera with 800x600 viewport
    When: Objects at various positions checked
    Then:
      - is_visible() returns True for on-screen
      - is_visible() returns False for off-screen  
      - Partially visible objects included
      - Margin parameter works (e.g., +50 pixels)
      - Culling is efficient (<0.1ms for 1000 objects)
    """
    # Error-Tags: ['CULLING_INCORRECT', 'PERFORMANCE_ISSUE']
```

## Implementation Requirements

### Core Components
```python
# camera.py
class Camera:
    def __init__(self, width: int, height: int):
        """Initialize camera with viewport size."""
        
    def update(self, dt: float) -> None:
        """Update camera position/state."""
        
    def follow(self, target_x: float, target_y: float,
               smooth_factor: float = 0.1) -> None:
        """Follow a target position smoothly."""
        
    def world_to_screen(self, world_x: float, world_y: float) -> Tuple[int, int]:
        """Convert world coordinates to screen coordinates."""
        
    def screen_to_world(self, screen_x: int, screen_y: int) -> Tuple[float, float]:
        """Convert screen coordinates to world coordinates."""
        
    def is_visible(self, x: float, y: float, 
                   width: float, height: float,
                   margin: float = 0) -> bool:
        """Check if rectangle is visible in viewport."""
        
    def set_position(self, x: float, y: float) -> None:
        """Set camera position directly."""
        
    def set_bounds(self, min_x: float, min_y: float,
                   max_x: float, max_y: float) -> None:
        """Set world boundary limits."""
```

### Camera Properties
```python
@property
def x(self) -> float:
    """Camera world X position."""
    
@property
def y(self) -> float:
    """Camera world Y position."""
    
@property
def viewport(self) -> pygame.Rect:
    """Get viewport rectangle in world space."""
```

### Error Tags
- `TRANSFORM_ERROR`: Coordinate transformation failed
- `POSITION_INVALID`: Camera position is invalid (NaN/Inf)
- `TRANSFORM_MATH_ERROR`: Mathematical error in transform
- `COORDINATE_OVERFLOW`: Coordinates exceed safe range
- `FOLLOW_TARGET_NULL`: No target to follow
- `SMOOTHING_FAILED`: Smooth follow calculation error
- `CULLING_INCORRECT`: Visibility check gave wrong result
- `PERFORMANCE_ISSUE`: Culling taking too long

## DDERF Strategies

### TRANSFORM_MATH_ERROR
1. **Detect**: Transform produces NaN or very large values
2. **Diagnose**: Check for division by zero, overflow
3. **Explain**: "Camera transform calculation error"
4. **Resolve**: Clamp to safe ranges, reset if needed
5. **Fix**: Add validation to all calculations

### COORDINATE_OVERFLOW
1. **Detect**: World coordinates exceed ±1,000,000
2. **Diagnose**: Check for runaway camera movement
3. **Explain**: "Camera moved outside safe bounds"
4. **Resolve**: Clamp to maximum safe coordinates
5. **Fix**: Implement hard limits on world size

## Security Considerations
- Validate all position inputs
- Prevent camera from revealing unintended areas
- Limit world bounds to prevent overflow

## Acceptance Criteria
- [ ] Camera transforms coordinates correctly
- [ ] Smooth following works without jitter
- [ ] Viewport culling is accurate
- [ ] Performance is good (1000+ objects)
- [ ] World bounds are respected
- [ ] All UTF tests pass
- [ ] Coverage ≥95%