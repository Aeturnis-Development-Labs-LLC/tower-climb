# Contract P0-S2-C1: State Management System

## Metadata
- **Contract ID**: P0-S2-C1
- **System**: Game Loop and States  
- **Priority**: Critical
- **Estimated Time**: 45 minutes
- **Dependencies**: P0-S1-C2
- **Version**: 1.0.0

## Description
Implement a state management system that handles transitions between Menu, Playing, and GameOver states. States should be properly initialized, updated, and cleaned up.

## UTF Test Blocks

### UTF-Block-P0-S2-C1-T1: State Machine Creation
```python
# Test: State machine initializes with menu state
def test_state_machine_initialization():
    """
    Given: State machine is created
    When: No state is explicitly set
    Then:
      - Current state is MenuState
      - State stack is empty
      - No previous state exists
      - State receives enter() call
    """
    # Error-Tags: ['NO_INITIAL_STATE', 'STATE_INIT_FAILED']
```

### UTF-Block-P0-S2-C1-T2: State Transitions
```python
# Test: States transition correctly
def test_state_transitions():
    """
    Given: State machine in MenuState
    When: Transition to PlayingState requested
    Then:
      - MenuState.exit() called
      - PlayingState.enter() called
      - Current state is PlayingState
      - Transition is atomic (no partial state)
    """
    # Error-Tags: ['TRANSITION_INTERRUPTED', 'STATE_LEAK']
```

### UTF-Block-P0-S2-C1-T3: State Stack Operations
```python
# Test: State stack push/pop work correctly
def test_state_stack():
    """
    Given: State machine in PlayingState
    When: PauseState is pushed, then popped
    Then:
      - Push: PauseState becomes active, PlayingState pauses
      - Pop: PlayingState resumes, PauseState exits
      - Stack maintains correct order
      - No state is lost
    """
    # Error-Tags: ['STACK_OVERFLOW', 'STACK_UNDERFLOW', 'STATE_LOST']
```

### UTF-Block-P0-S2-C1-T4: Invalid State Handling
```python
# Test: Invalid states are rejected
def test_invalid_state_handling():
    """
    Given: State machine is running
    When: None or invalid state is set
    Then:
      - State change is rejected
      - Current state remains active
      - Error is logged
      - No crash occurs
    """
    # Error-Tags: ['INVALID_STATE', 'NULL_STATE_ERROR']
```

## Implementation Requirements

### Core Components
```python
# state_machine.py
class StateMachine:
    def __init__(self):
        """Initialize state machine."""
        
    def set_state(self, state: GameState) -> None:
        """Replace current state."""
        
    def push_state(self, state: GameState) -> None:
        """Push state onto stack."""
        
    def pop_state(self) -> None:
        """Pop state from stack."""
        
    def update(self, dt: float) -> None:
        """Update current state."""
        
    def draw(self, window: Window) -> None:
        """Draw current state."""
        
    def handle_event(self, event: pygame.event.Event) -> None:
        """Pass event to current state."""

# States
class MenuState(GameState):
    """Main menu state."""
    
class PlayingState(GameState):
    """Main gameplay state."""
    
class GameOverState(GameState):
    """Game over screen state."""
```

### Error Tags
- `NO_INITIAL_STATE`: State machine has no starting state
- `STATE_INIT_FAILED`: State initialization error
- `TRANSITION_INTERRUPTED`: State change was interrupted
- `STATE_LEAK`: Previous state not properly cleaned
- `STACK_OVERFLOW`: State stack exceeded maximum depth
- `STACK_UNDERFLOW`: Pop called on empty stack
- `STATE_LOST`: State reference lost during transition
- `INVALID_STATE`: Attempted to set invalid state
- `NULL_STATE_ERROR`: Null/None state provided

## DDERF Strategies

### TRANSITION_INTERRUPTED
1. **Detect**: Exception during exit/enter methods
2. **Diagnose**: Check which phase failed, state of resources
3. **Explain**: "State transition failed - system in inconsistent state"
4. **Resolve**: Complete transition or rollback entirely
5. **Fix**: Make transitions atomic with try/finally

### STACK_OVERFLOW
1. **Detect**: Stack depth exceeds limit (e.g., 10 states)
2. **Diagnose**: Check for recursive state pushes
3. **Explain**: "State stack too deep - possible infinite loop"
4. **Resolve**: Clear stack, return to safe state
5. **Fix**: Add stack depth limit, detect circular pushes

## Security Considerations
- Validate state objects before transitions
- Prevent arbitrary code execution via states
- Limit stack depth to prevent DoS

## Acceptance Criteria
- [ ] Three states implemented (Menu, Playing, GameOver)
- [ ] Transitions work correctly
- [ ] State stack supports push/pop
- [ ] Invalid states handled gracefully
- [ ] No memory leaks during transitions
- [ ] All UTF tests pass
- [ ] Coverage â‰¥95%