# AI-Generated by CAFE v5.1-ACG - CC BY-NC 4.0 License
"""State management system for game states."""

from collections import deque
from typing import Deque, Optional

import pygame

from tower_climb.core.game_state import GameState
from tower_climb.core.window import Window


class StateMachine:
    """Manages game state transitions and stack operations."""

    MAX_STACK_DEPTH = 10

    def __init__(self) -> None:
        """Initialize state machine with menu state."""
        self._current_state: Optional[GameState] = None
        self._previous_state: Optional[GameState] = None
        self._state_stack: Deque[GameState] = deque()
        self._transitioning = False

        # Start with menu state
        initial_state = MenuState()
        self._set_state_internal(initial_state)

    @property
    def current_state(self) -> Optional[GameState]:
        """Get current active state."""
        return self._current_state

    @property
    def previous_state(self) -> Optional[GameState]:
        """Get previous state."""
        return self._previous_state

    def get_state_stack_size(self) -> int:
        """Get number of states on the stack."""
        return len(self._state_stack)

    def set_state(self, state: GameState) -> None:
        """Replace current state with new state.

        Args:
            state: New state to transition to

        Raises:
            ValueError: If state is None
            TypeError: If state is not a GameState
            RuntimeError: If transition fails
        """
        if state is None:
            raise ValueError("NULL_STATE_ERROR: Cannot set None as state")

        if not isinstance(state, GameState):
            raise TypeError(f"INVALID_STATE: Expected GameState, got {type(state)}")

        self._set_state_internal(state)

    def _set_state_internal(self, state: GameState) -> None:
        """Internal state setting with lifecycle management."""
        if self._transitioning:
            return  # Ignore transitions during transitions

        self._transitioning = True
        old_state = self._current_state

        try:
            # Exit old state
            if old_state:
                old_state.exit()

            # Update state references
            self._previous_state = old_state
            self._current_state = state

            # Enter new state
            state.enter()

        except Exception as e:
            # Rollback on failure
            self._current_state = old_state
            self._previous_state = None
            raise RuntimeError(f"State transition failed: {e}") from e
        finally:
            self._transitioning = False

    def push_state(self, state: GameState) -> None:
        """Push new state onto stack, pausing current state.

        Args:
            state: State to push

        Raises:
            ValueError: If state is None
            TypeError: If state is not a GameState
            RuntimeError: If stack is full
        """
        if state is None:
            raise ValueError("NULL_STATE_ERROR: Cannot push None as state")

        if not isinstance(state, GameState):
            raise TypeError(f"INVALID_STATE: Expected GameState, got {type(state)}")

        if len(self._state_stack) >= self.MAX_STACK_DEPTH:
            raise RuntimeError(
                f"STACK_OVERFLOW: State stack depth exceeded "
                f"({self.MAX_STACK_DEPTH})"
            )

        # Pause current state
        if self._current_state:
            if hasattr(self._current_state, "pause"):
                self._current_state.pause()
            self._state_stack.append(self._current_state)

        # Activate new state
        self._current_state = state
        state.enter()

    def pop_state(self) -> None:
        """Pop state from stack, resuming previous state."""
        if not self._state_stack:
            # Nothing to pop
            return

        # Exit current state
        if self._current_state:
            self._current_state.exit()

        # Restore previous state
        self._current_state = self._state_stack.pop()
        if self._current_state and hasattr(self._current_state, "resume"):
            self._current_state.resume()

    def update(self, dt: float) -> None:
        """Update current state.

        Args:
            dt: Delta time in seconds
        """
        if self._current_state and not self._transitioning:
            self._current_state.update(dt)

    def draw(self, window: Window) -> None:
        """Draw current state.

        Args:
            window: Window to draw to
        """
        if self._current_state and not self._transitioning:
            self._current_state.draw(window)

    def handle_event(self, event: pygame.event.Event) -> None:
        """Handle event in current state.

        Args:
            event: Pygame event to handle
        """
        if self._current_state and not self._transitioning:
            self._current_state.handle_event(event)


class MenuState(GameState):
    """Main menu state."""

    def enter(self) -> None:
        """Called when entering state."""
        pass

    def exit(self) -> None:
        """Called when exiting state."""
        pass

    def update(self, dt: float) -> None:
        """Update menu state."""
        pass

    def draw(self, window: Window) -> None:
        """Draw menu state."""
        # For now, just clear screen with dark blue
        window.clear((20, 20, 40))

    def handle_event(self, event: pygame.event.Event) -> None:
        """Handle menu events."""
        pass


class PlayingState(GameState):
    """Main gameplay state."""

    def enter(self) -> None:
        """Called when entering state."""
        pass

    def exit(self) -> None:
        """Called when exiting state."""
        pass

    def pause(self) -> None:
        """Called when state is paused (pushed to stack)."""
        pass

    def resume(self) -> None:
        """Called when state is resumed (popped from stack)."""
        pass

    def update(self, dt: float) -> None:
        """Update game state."""
        pass

    def draw(self, window: Window) -> None:
        """Draw game state."""
        # For now, just clear screen with dark green
        window.clear((20, 40, 20))

    def handle_event(self, event: pygame.event.Event) -> None:
        """Handle game events."""
        pass


class GameOverState(GameState):
    """Game over screen state."""

    def enter(self) -> None:
        """Called when entering state."""
        pass

    def exit(self) -> None:
        """Called when exiting state."""
        pass

    def update(self, dt: float) -> None:
        """Update game over state."""
        pass

    def draw(self, window: Window) -> None:
        """Draw game over state."""
        # For now, just clear screen with dark red
        window.clear((40, 20, 20))

    def handle_event(self, event: pygame.event.Event) -> None:
        """Handle game over events."""
        pass
