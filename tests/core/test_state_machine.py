# AI-Generated by CAFE v5.1-ACG - CC BY-NC 4.0 License
"""Tests for state management system - Contract P0-S2-C1."""

from unittest.mock import Mock, patch

import pygame
import pytest

from tower_climb.core.game_state import GameState
from tower_climb.core.state_machine import (
    GameOverState,
    MenuState,
    PlayingState,
    StateMachine,
)
from tower_climb.core.window import Window


class TestStateMachineCreation:
    """UTF-Block-P0-S2-C1-T1: State Machine Creation tests."""

    def test_state_machine_initialization(self):
        """Test state machine initializes with menu state."""
        machine = StateMachine()

        # Should start with MenuState
        assert isinstance(machine.current_state, MenuState)
        assert machine.get_state_stack_size() == 0
        assert machine.previous_state is None

        # Verify enter was called
        with patch.object(MenuState, "enter") as mock_enter:
            StateMachine()
            mock_enter.assert_called_once()

    def test_initial_state_lifecycle(self):
        """Test initial state gets proper lifecycle calls."""
        with patch("tower_climb.core.state_machine.MenuState") as MockMenuState:
            mock_instance = Mock(spec=GameState)
            MockMenuState.return_value = mock_instance

            StateMachine()

            # Verify state was created and entered
            MockMenuState.assert_called_once()
            mock_instance.enter.assert_called_once()
            mock_instance.exit.assert_not_called()


class TestStateTransitions:
    """UTF-Block-P0-S2-C1-T2: State Transitions tests."""

    def test_state_transitions(self):
        """Test states transition correctly."""
        machine = StateMachine()
        menu_state = machine.current_state

        # Create a playing state
        playing_state = PlayingState()

        # Mock the lifecycle methods
        with (
            patch.object(menu_state, "exit") as mock_menu_exit,
            patch.object(playing_state, "enter") as mock_playing_enter,
        ):
            machine.set_state(playing_state)

            # Verify transition sequence
            mock_menu_exit.assert_called_once()
            mock_playing_enter.assert_called_once()

            # Verify current state
            assert machine.current_state is playing_state
            assert machine.previous_state is menu_state

    def test_transition_is_atomic(self):
        """Test transitions are atomic - no partial states."""
        machine = StateMachine()
        initial_state = machine.current_state

        # Create a state that fails on enter
        failing_state = Mock(spec=GameState)
        failing_state.enter.side_effect = RuntimeError("Enter failed")

        # Attempt transition
        with pytest.raises(RuntimeError):
            machine.set_state(failing_state)

        # Should remain in initial state
        assert machine.current_state is initial_state

    def test_state_exit_cleanup(self):
        """Test previous state is properly cleaned up."""
        machine = StateMachine()

        # Transition through multiple states
        playing_state = PlayingState()
        game_over_state = GameOverState()

        with patch.object(machine.current_state, "exit") as mock_exit:
            machine.set_state(playing_state)
            mock_exit.assert_called_once()

        with patch.object(playing_state, "exit") as mock_exit2:
            machine.set_state(game_over_state)
            mock_exit2.assert_called_once()


class TestStateStackOperations:
    """UTF-Block-P0-S2-C1-T3: State Stack Operations tests."""

    def test_state_stack(self):
        """Test state stack push/pop work correctly."""
        machine = StateMachine()

        # Start in playing state
        playing_state = PlayingState()
        machine.set_state(playing_state)

        # Create pause state
        pause_state = Mock(spec=GameState)

        # Push pause state
        with patch.object(playing_state, "pause") as mock_pause:
            machine.push_state(pause_state)

            # Verify pause was called on playing state
            mock_pause.assert_called_once()

            # Verify pause state is active
            assert machine.current_state is pause_state
            pause_state.enter.assert_called_once()

            # Stack should have playing state
            assert machine.get_state_stack_size() == 1

        # Pop back to playing state
        with (
            patch.object(pause_state, "exit") as mock_exit,
            patch.object(playing_state, "resume") as mock_resume,
        ):
            machine.pop_state()

            # Verify lifecycle calls
            mock_exit.assert_called_once()
            mock_resume.assert_called_once()

            # Should be back in playing state
            assert machine.current_state is playing_state
            assert machine.get_state_stack_size() == 0

    def test_stack_maintains_order(self):
        """Test stack maintains correct order with multiple pushes."""
        machine = StateMachine()

        states = [Mock(spec=GameState) for _ in range(3)]
        initial_state = machine.current_state

        # Push multiple states
        for state in states:
            machine.push_state(state)

        # Pop them in reverse order
        for state in reversed(states):
            assert machine.current_state is state
            machine.pop_state()

        # Should be back to initial
        assert machine.current_state is initial_state

    def test_pop_empty_stack(self):
        """Test pop on empty stack is handled gracefully."""
        machine = StateMachine()
        initial_state = machine.current_state

        # Pop empty stack shouldn't crash
        machine.pop_state()

        # Should remain in current state
        assert machine.current_state is initial_state

    def test_stack_depth_limit(self):
        """Test stack has depth limit to prevent overflow."""
        machine = StateMachine()

        # Try to push too many states
        for i in range(15):  # Assuming limit is 10
            state = Mock(spec=GameState)
            if i < 10:
                machine.push_state(state)
            else:
                # Should reject push after limit
                with pytest.raises(RuntimeError, match="STACK_OVERFLOW"):
                    machine.push_state(state)

        assert machine.get_state_stack_size() == 10


class TestInvalidStateHandling:
    """UTF-Block-P0-S2-C1-T4: Invalid State Handling tests."""

    def test_invalid_state_handling(self):
        """Test invalid states are rejected."""
        machine = StateMachine()
        initial_state = machine.current_state

        # Try to set None state
        with pytest.raises(ValueError, match="NULL_STATE_ERROR"):
            machine.set_state(None)

        # State should not change
        assert machine.current_state is initial_state

        # Try to set non-GameState object
        with pytest.raises(TypeError, match="INVALID_STATE"):
            machine.set_state("not a state")

        # State should still not change
        assert machine.current_state is initial_state

    def test_push_invalid_state(self):
        """Test pushing invalid state is rejected."""
        machine = StateMachine()
        stack_size = machine.get_state_stack_size()

        # Try to push None
        with pytest.raises(ValueError, match="NULL_STATE_ERROR"):
            machine.push_state(None)

        # Stack should not change
        assert machine.get_state_stack_size() == stack_size

    def test_state_machine_continues_after_error(self):
        """Test state machine continues working after error."""
        machine = StateMachine()

        # Cause an error
        try:
            machine.set_state(None)
        except ValueError:
            pass

        # Should still be able to transition
        new_state = PlayingState()
        machine.set_state(new_state)
        assert machine.current_state is new_state


class TestStateMachineIntegration:
    """Integration tests for state machine."""

    def test_update_propagates_to_state(self):
        """Test update calls are propagated to current state."""
        machine = StateMachine()

        mock_state = Mock(spec=GameState)
        machine.set_state(mock_state)

        # Update should propagate
        machine.update(0.016)
        mock_state.update.assert_called_once_with(0.016)

    def test_draw_propagates_to_state(self):
        """Test draw calls are propagated to current state."""
        machine = StateMachine()
        window = Mock(spec=Window)

        mock_state = Mock(spec=GameState)
        machine.set_state(mock_state)

        # Draw should propagate
        machine.draw(window)
        mock_state.draw.assert_called_once_with(window)

    def test_event_propagates_to_state(self):
        """Test events are propagated to current state."""
        machine = StateMachine()

        mock_state = Mock(spec=GameState)
        machine.set_state(mock_state)

        # Create mock event
        event = Mock(spec=pygame.event.Event)
        event.type = pygame.KEYDOWN

        # Event should propagate
        machine.handle_event(event)
        mock_state.handle_event.assert_called_once_with(event)

    def test_no_update_during_transition(self):
        """Test updates are blocked during state transition."""
        machine = StateMachine()

        # Create a state with slow enter method
        slow_state = Mock(spec=GameState)
        enter_called = False

        def slow_enter():
            nonlocal enter_called
            enter_called = True
            # Try to update during enter - should be ignored
            machine.update(0.016)

        slow_state.enter = slow_enter
        slow_state.update = Mock()

        machine.set_state(slow_state)

        # Enter should have been called
        assert enter_called
        # But update should not propagate during transition
        slow_state.update.assert_not_called()


class TestConcreteStates:
    """Test concrete state implementations."""

    def test_menu_state_lifecycle(self):
        """Test MenuState lifecycle methods."""
        state = MenuState()

        # Should not raise
        state.enter()
        state.exit()
        state.update(0.016)
        state.handle_event(Mock(spec=pygame.event.Event))

    def test_menu_state_draw(self):
        """Test MenuState draws correctly."""
        state = MenuState()
        window = Mock(spec=Window)

        state.draw(window)
        window.clear.assert_called_once_with((20, 20, 40))

    def test_playing_state_lifecycle(self):
        """Test PlayingState lifecycle methods."""
        state = PlayingState()

        # Should not raise
        state.enter()
        state.exit()
        state.pause()
        state.resume()
        state.update(0.016)
        state.handle_event(Mock(spec=pygame.event.Event))

    def test_playing_state_draw(self):
        """Test PlayingState draws correctly."""
        state = PlayingState()
        window = Mock(spec=Window)

        state.draw(window)
        window.clear.assert_called_once_with((20, 40, 20))

    def test_game_over_state_lifecycle(self):
        """Test GameOverState lifecycle methods."""
        state = GameOverState()

        # Should not raise
        state.enter()
        state.exit()
        state.update(0.016)
        state.handle_event(Mock(spec=pygame.event.Event))

    def test_game_over_state_draw(self):
        """Test GameOverState draws correctly."""
        state = GameOverState()
        window = Mock(spec=Window)

        state.draw(window)
        window.clear.assert_called_once_with((40, 20, 20))


class TestStateMachineEdgeCases:
    """Test edge cases and error conditions."""

    def test_none_current_state_safe(self):
        """Test operations with None current state are safe."""
        machine = StateMachine()
        # Force None state (shouldn't happen normally)
        machine._current_state = None

        # These should not crash
        machine.update(0.016)
        machine.draw(Mock(spec=Window))
        machine.handle_event(Mock(spec=pygame.event.Event))

    def test_transitioning_blocks_operations(self):
        """Test that operations are blocked during transitions."""
        machine = StateMachine()
        machine._transitioning = True

        mock_state = Mock(spec=GameState)
        machine._current_state = mock_state

        # These should not propagate
        machine.update(0.016)
        machine.draw(Mock(spec=Window))
        machine.handle_event(Mock(spec=pygame.event.Event))

        # Verify nothing was called
        mock_state.update.assert_not_called()
        mock_state.draw.assert_not_called()
        mock_state.handle_event.assert_not_called()

    def test_recursive_state_change_prevented(self):
        """Test recursive state changes are prevented."""
        machine = StateMachine()

        # Create state that tries to change state in enter
        recursive_state = Mock(spec=GameState)

        def recursive_enter():
            machine._set_state_internal(PlayingState())

        recursive_state.enter = recursive_enter

        # This should work but not allow the recursive call
        machine.set_state(recursive_state)
        assert machine.current_state is recursive_state
